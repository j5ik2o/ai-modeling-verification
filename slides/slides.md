---
theme: seriph
colorSchema: auto
class: text-center
highlighter: shiki
lineNumbers: false
info: 曖昧なプロンプトでも正しいコードが書ける理由
drawings:
  persist: false
transition: slide-left
title: 曖昧なプロンプトでも正しいコードが書ける理由
mdc: true
layout: cover
fonts:
  sans: 'Noto Sans JP'
  serif: 'Noto Serif JP'
  mono: 'Fira Code'
hideInToc: true
---

# 曖昧なプロンプトでも
# 正しいコードが書ける理由
## 〜 Always-Valid Domain Model の表現力 〜

かとじゅん(@j5ik2o)


<!--
【時間: 30秒 | 累計: 0:30】

皆さん、こんにちは。本日は「曖昧なプロンプトでも正しいコードが書ける理由」というテーマで、Always-Valid Domain Modelの表現力についてお話しします。

Claude CodeやCursorといったAIコーディング支援ツールが普及する中で、ドメインモデルの設計がAI生成コードの品質にどのような影響を与えるのか、実験を通じて検証しました。

15分という限られた時間ですが、実験結果を中心に具体的な知見を共有させていただきます。それでは始めます。
-->

---

# アジェンダ

- 背景と目的
- AVDM (Always-Valid Domain Model) とは
- お題:EV充電料金の計算
- プロンプト定義
- 実験設計
- デモと実験結果
- 明確なプロンプトでの安定化
- 失敗パターン（曖昧プロンプト × 非AVDM）
- 成功パターン（曖昧プロンプト × AVDM）
- ChargeableEnergy が防ぐバグ
- 学び

<!--
【時間: 30秒 | 累計: 1:00】

本日のアジェンダです。まず背景と目的、そしてAVDMという手法について説明します。お題と実験設計を説明した後、実際の実験をデモでお見せします。

その後、実験結果を詳しく見ていきます。明確なプロンプトでの安定化、失敗パターン、成功パターンの順に解説し、最後にChargeableEnergyの具体例と学びをまとめます。

特に注目していただきたいのは、曖昧なプロンプトでの差です。では早速、背景から見ていきましょう。
-->

---

# 背景と目的

**背景**
- AIコーディング支援の活用が進む中、ドメインモデルの設計がコード品質に与える影響を定量的に測定したい

**目的**
- Always-Valid Domain Model(AVDM) が品質に与える影響を検証
- EV充電料金計算ドメインで、**曖昧 vs 明確**プロンプト、**非AVDM(model-a) vs AVDM(model-b)** の4通りを比較

<!--
【時間: 1分 | 累計: 2:00】

まず背景です。Claude CodeやCursorなどのAIコーディング支援ツールが急速に普及しています。しかし、ドメインモデルの設計品質がAI生成コードにどう影響するかについては、まだ十分に解明されていません。

そこで今回の目的は、Always-Valid Domain Model、略してAVDMが品質に与える影響を検証することです。

具体的には、EV充電料金計算というドメインを題材に、2つの軸で実験を行いました。1つ目の軸はプロンプトの明確さ、曖昧な指示と明確な指示の違い。2つ目の軸はモデル設計、非AVDMとAVDMの違いです。

この2かける2で、合計4パターンを同一条件で並列実行し、定量的に比較しました。では次に、AVDMとは何かを説明します。
-->

---

# AVDM (Always-Valid Domain Model) とは

**コンセプト**
- 不正な状態を型レベルで防ぐドメインモデリング手法
- 値オブジェクトに不変条件を組み込み、無効な値の生成を防止

**仕組み**
- コンストラクタで不変条件を検証
- 検証失敗時は `Result` 型でエラーを返却
- 一度生成されたオブジェクトは常に正しい状態を保証

**例: ChargeableEnergy**
```rust
pub fn new(total: KwhMilli, billed: KwhMilli) -> Result<Self, ...> {
  if billed > total { return Err(...); }  // 不変条件: billed ≤ total
  Ok(Self { total, billed })
}
```

<!--
【時間: 1分30秒 | 累計: 3:30】

AVDMとは、Always-Valid Domain Modelの略で、「常に正しい状態」を保証するドメインモデル設計手法です。

コンセプトは、不正な状態を型レベルで防ぐことです。値オブジェクトに不変条件を組み込むことで、無効な値の生成そのものを防止します。

仕組みを見ていきましょう。重要なのは「コンストラクタで検証する」という点です。検証に失敗した場合はResult型でエラーを返却し、一度生成されたオブジェクトは必ず正しい状態を保証します。つまり、無効な状態のオブジェクトは存在しないということです。

スライドのコード例を見てください。ChargeableEnergyという課金対象エネルギーを表す値オブジェクトです。ここでは「課金対象エネルギーが総エネルギーを超えてはいけない」という不変条件を、コンストラクタで強制しています。

このように、Rustの型システムとResult型を活用することで、型安全なドメインモデルを実現します。では次に、今回の実験のお題を見ていきましょう。
-->

---

# お題:EV充電料金の計算

- ユーザーが充電スタンドで `start` → `snapshot`（途中課金確認）→ `stop` する流れをモデル化
- 課金の基本式：**料金 = 単価（円/kWh） × 課金対象エネルギー**
- 主要ルール（spec.md のシナリオに対応）
  1. **無料5分（scenario1〜3,7）**：開始5分までに相当するエネルギーは請求対象から除外
  2. **按分は時間比例＆切り捨て（scenario4,12）**：エネルギーは時間で均等分布とみなし、小数は floor 処理
  3. **単調増加と決定性（scenario5,11）**：利用時間が伸びるほど料金・エネルギーは減らず、同じ入力なら同じ結果
  4. **停止後課金禁止（scenario6）**：`stop` 完了後に再課金しようとすると拒否
  5. **不正入力防御（scenario8〜10,14,15）**：ゼロ/負エネルギー、時間逆行、上限超過などはエラー

<!--
【時間: 1分 | 累計: 4:30】

実験のお題は、EV充電の料金計算システムです。これは実際のビジネスロジックに近い、適度な複雑さを持つドメインです。

ユーザーが充電スタンドでstartして、途中でsnapshotで課金確認し、最後にstopするという流れをモデル化します。課金の基本式はシンプルで、単価かけるエネルギーです。

重要なのは5つの主要ルールです。1つ目、無料5分。最初の5分は課金対象外とします。これはよくあるキャンペーンですね。

2つ目、按分計算。エネルギーは時間に比例して均等分布するとみなし、小数は切り捨て処理します。

3つ目、単調増加と決定性。利用時間が伸びれば料金も増える、そして同じ入力なら必ず同じ結果になる、という参照透明性の基本です。

4つ目、停止後課金禁止。stop完了後に再課金しようとすると拒否します。状態遷移の制約ですね。

5つ目、不正入力防御。ゼロや負のエネルギー、時間逆行、上限超過などはすべてエラーとします。

これら5つのルールに対応する、合計15個のシナリオをテストケースとして用意しました。では次に、プロンプトの定義を見ていきましょう。
-->

---

# プロンプト定義

- **明確なプロンプト**
    - 目的・変更範囲・ビジネスルール・テスト基準を明文化
    - 例: 「`modules/model-a-non-avdm/src/session.rs` の `stop` を修正し、受入テスト `scenario6` を通す。状態遷移図に合わせて Stop 後の二重課金を防ぐこと」
- **曖昧プロンプト**
  - タスク目標は示すが、変更対象や受け入れ条件が曖昧
  - 「料金計算を直してください」「失敗テストをとにかく通す」など抽象的な指示
  - LLM側の推測が増え、ドメイン制約を踏み外す危険が高い
- LLM の探索余地を適切に絞り、決定的な挙動と再現性を高める

<!--
【時間: 1分 | 累計: 5:30】

プロンプトの品質が、今回の実験の独立変数です。

明確なプロンプトでは、目的、変更範囲、ビジネスルール、テスト基準のすべてを明文化します。スライドの例を見てください。ファイルパス、関数名、テストケース番号まで具体的に指定し、ビジネスルールも明示しています。このように4W1Hを具体化することで、AIの探索空間を適切に絞ります。

一方、曖昧なプロンプトでは、タスクの目標は示しますが、変更対象や受け入れ条件を曖昧にします。「料金計算を直してください」「失敗テストをとにかく通してください」といった、抽象度の高い指示です。これは現実でもよくある指示パターンですね。

このような曖昧な指示では、LLM側の推測が増えるため、ドメイン制約を踏み外す危険が高くなります。

明確なプロンプトと曖昧なプロンプト、この差がAIの推論にどう影響するかを測定するのが、今回の実験です。では次に、実験設計を見ていきましょう。
-->

---

# 実験設計

- `scripts/run-worktree-all.sh` が4ジョブを並列投入し、各ジョブは `tmp/worktrees/<prefix>-<model>-<mode>-XXXXXX` に作成した worktree で `claude` モードを駆動
- 実行ごとにログと PID を `tmp/logs/<timestamp>` に保存し、必要に応じて worktree を `tmp/worktrees/<timestamp>` に保持（今回のラン: `tmp/logs/run-20251025-231331` / `tmp/worktrees/run-20251025-231331`）
- 成果物：各ログ (`*.log`)、補助 PID (`*.pid`)、保存済み worktree、必要に応じてデモ動画
- 計測指標：テスト結果（単体・受入）、経過時間、代表エラーメッセージ

<!--
【時間: 1分 | 累計: 6:30】

実験設計では、再現性を最重視しました。

run-worktree-all.shというスクリプトで、4パターンを並列実行します。各実験はgit worktreeで完全に隔離されているため、相互干渉はありません。

すべてのログ、PID、生成コードを、タイムスタンプ付きのディレクトリに保存します。今回お見せする実験は、2025年10月25日23時13分31秒に実行したものです。

計測指標は、テストの成功率、経過時間、そしてエラーの内容です。この3つを比較することで、プロンプトとモデル設計の影響を定量的に評価します。

この仕組みにより、完全な再現可能性を確保しています。では次に、実際の実験の様子をデモでお見せします。
-->

---

# デモ

<video src="file:///Users/j5ik2o/Sources/ai-modeling-verification/experiments/run-20251025-231331/2025-10-25 23-13-37.mp4" controls style="width: 90%; margin: 1rem auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.4);"></video>

<!--
【時間: 1分50秒 | 累計: 8:20】
※動画を2倍速で再生

それでは、実際の実験実行の様子をご覧ください。動画は2倍速で再生します。

画面には4つのターミナルが表示されています。左上が明確プロンプトとmodel-a、右上が曖昧プロンプトとmodel-a、左下が明確プロンプトとmodel-b、右下が曖昧プロンプトとmodel-bです。

4つのジョブが並列で動いています。Claude Codeが各worktreeでコード生成とテスト実行を繰り返している様子が見えますね。

所々でテスト結果が表示されています。成功したものもあれば、失敗しているものもあります。この違いがどこから来るのか、次のスライドで詳しく見ていきましょう。
-->

---

# 実験結果マトリクス

<small>データソース: `experiments/run-20251025-231331`</small>

| プロンプト | モデル | 単体テスト | 受入テスト | 経過時間 |
|-------| --- | --- | --- | --- |
| 明確    | model-a | ✅ 8/8 | ✅ 9/9 | 02:14 |
| 明確    | model-b | ✅ 11/11 | ✅ 9/9 | 02:54 |
| 曖昧  | model-a | ✅ 16/16 | ⚠️ 5/9 | 03:15 |
| 曖昧  | model-b | ✅ 17/17 | ✅ 9/9 | 03:22 |

> ⚠️ `model-a billed energy mismatch` が scenario1/5/11/stop 検証で発生し、曖昧プロンプト × model-a が再び破綻。

<!--
【時間: 1分 | 累計: 9:20】

実験結果の全体像です。この表が今回の最も重要な発見です。

注目していただきたいポイントが3つあります。

1つ目、明確なプロンプトなら、両方のモデルとも受入テストで完全合格です。9個のシナリオすべてをパスしています。

2つ目、曖昧なプロンプトと非AVDMの組み合わせ、つまりmodel-aだけが失敗しています。受入テストで9個中5個しか通っていません。

3つ目、曖昧なプロンプトでもAVDM、つまりmodel-bは成功しています。9個すべてパスです。

単体テストの件数に差があるのは、AVDMでは不変条件のテストが増えるため、自然にテスト数が多くなるからです。

経過時間を見ると、明確なプロンプトの方が速いですね。これは探索空間が狭いためです。

この結果が示すのは、AVDMは曖昧なプロンプトに対する防御力を持つ、ということです。では次に、明確なプロンプトの効果を見ていきましょう。
-->

---

# 明確なプロンプトでの安定化

- 明確な仕様提示により、model-a でも期待通りの修正が入り 9/9 合格
- model-b ではドメインオブジェクトの不変条件がさらに強化
- 所要時間が短縮され、ワークフロー全体の決定性が向上
- 解析ログ: `experiments/run-20251025-231331/precise-a.log` / `experiments/run-20251025-231331/precise-b.log`

```text
test result: ok. 9 passed; 0 failed; ... finished in 0.00s
elapsed: 02:14 (model-a precise)

test result: ok. 9 passed; 0 failed; ... finished in 0.00s
elapsed: 02:54 (model-b precise)
```

<!--
【時間: 45秒 | 累計: 10:05】

明確なプロンプトの効果を見ていきます。

仕様を明確に提示すれば、非AVDMのmodel-aでも完全に成功しています。9個のシナリオすべてパスです。つまり、プロンプトが明確なら、非AVDMでも問題ないということです。

しかし、次のスライドで見るように、プロンプトが曖昧になると、大きな差が出てきます。

経過時間を見ると、model-aは2分14秒、model-bは2分54秒です。model-bが40秒長いのは、不変条件を追加するコストです。しかし、このコストが後で効いてきます。では次に、失敗パターンを詳しく見ていきましょう。
-->

---

# 曖昧プロンプト × 非AVDM 失敗の実相(1/2)

```
assertion `left == right` failed: model-a billed energy mismatch for scenario1_six_minutes
  left: 2400
 right: 400
```

- 無料5分の按分ロジックが欠落し、6分目以降の課金量が過大になった（scenario1/5/11/stop が失敗）
- 時間が延びれば料金が増えるはず（単調増加）という前提や、同じ入力なら必ず同じ結果になる決定性（Determinism。参照透明性を成立させる前提の一つ）が壊れ、受入テスト 9 本のうち 4 本が連鎖的に失敗

<!--
【時間: 1分 | 累計: 11:05】

曖昧なプロンプトと非AVDMの組み合わせで、何が起きたのか。詳しく見ていきます。

エラーメッセージを見てください。期待値が400に対して、2400を返しています。6倍の過大請求です。無料5分を引いていないんですね。

このバグが波及して、4つのテストが連鎖的に失敗しました。scenario1は6分間の課金テスト、scenario5は単調増加性のテスト、scenario11は決定性のテスト、そしてstop検証は停止後の状態確認です。

1つのバグが、4つのテストを破壊してしまいました。では次に、生成されたコードを見てみましょう。
-->

---

# 曖昧プロンプト × 非AVDM 失敗の実相(2/2)

```rust
if elapsed_millis <= FREE_DURATION_MILLIS {
    session.billed_kwh_milli = 0;
    // ...
    return Ok(0);
}
// 無料期間を差し引かず全量を課金対象に設定してしまう
session.billed_kwh_milli = session.kwh_milli;
```

- <small>生成コード: `experiments/run-20251025-231331/worktrees/ambiguous-model-a-claude.iNiQaQ/modules/model-a-non-avdm/src/session.rs:73-95` で無料時間を判定後も `session.billed_kwh_milli = session.kwh_milli;` と全量課金。FREE_DURATION 定数を持ちながら、時間按分が未実装のまま残った</small>
- その結果、`stop_scenarios_match_expected`（backtrace: `spec-tests/tests/common.rs:104`）が想定値 400 ミリkWh に対し 2400 ミリkWh を返し、連鎖的に scenario5/11 と決定性検証が破綻
- <small>解析ログ: `experiments/run-20251025-231331/ambiguous-a.log`</small>
- **非AVDM** では例外を型で防げず、バグが再注入されやすい

<!--
【時間: 45秒 | 累計: 11:50】

生成されたコードを見ると、原因が明確です。

無料時間の判定はしています。if文で5分以内なら課金ゼロとしていますね。しかし、6分以上の場合の按分処理が抜けています。

最後の行を見てください。全量を課金対象にしてしまっています。5分分を引く処理が欠落しているんです。

FREE_DURATION定数は定義されているのに、使われていません。これが非AVDMの弱点です。バリデーションが分散し、漏れやすいのです。

では次に、同じ曖昧プロンプトでも、AVDMが成功した理由を見ていきましょう。
-->

---

# 曖昧プロンプト × AVDM 成功要因(1/2)

```text
test scenario5_progressive_billing_is_monotonic ... ok
test scenario6_rejects_billing_after_stop ... ok
test stop_scenarios_match_expected ... ok
```

- `SessionTimeline` や `ChargeableEnergy` など AVDM の値オブジェクトが不変条件を担保し、AI が生成した `Session` の変更でも型制約が破綻を防いだ
- 編集開始前に AI が値オブジェクト実装を読み込み 不変条件を先に理解してから `Session` 実装へ着手
    - <small>ログ冒頭: `experiments/run-20251025-231331/ambiguous-b.log:10-60` </small>
- <small>受入テスト `scenario10_invalid_timeline_is_rejected` / `scenario9_negative_energy_is_rejected` / `scenario15_energy_over_limit_is_rejected` が全て成功し、終了時刻逆転・負/過大エネルギーを自動的に拒否（ログ: `experiments/run-20251025-231331/ambiguous-b.log:118-128`）</small>
- 受入テスト 9/9 合格、単体テストも完全成功。時間は要したが、ロジック破綻は発生せず（`elapsed: 03:22`）
- <small>解析ログ: `experiments/run-20251025-231331/ambiguous-b.log`</small>

<!--
【時間: 1分 | 累計: 12:50】

同じ曖昧なプロンプトなのに、AVDMは成功しました。なぜでしょうか。

テスト結果を見てください。scenario5の単調増加性、scenario6の停止後課金禁止、そしてstop検証、すべて成功しています。

重要なポイントは、AIが値オブジェクトを先に読んだことです。ログの10行目から60行目を見ると、SessionTimelineやChargeableEnergyの実装を読んでいます。不変条件を理解してから、Session実装に着手したんですね。

結果として、不正入力を自動的に拒否しています。scenario9は負のエネルギー、scenario10は時刻逆行、scenario15は上限超過、すべて型レベルで防御されました。

時間は3分22秒と長くかかりましたが、品質は保たれています。では次に、生成されたコードを見てみましょう。
-->

---

# 曖昧プロンプト × AVDM 成功要因(2/2)

```rust
fn compute_bill(...) -> Result<SessionBill, SessionValueError> {
  let timeline = SessionTimeline::between(started_at, ended_at)?;
  let window = timeline.consume_grace_period(Self::grace_period());
  let energy = ChargeableEnergy::allocate(total_energy, window)?;
  SessionBill::settle(energy, rate)
}
```

<small>コード出典: `experiments/run-20251025-231331/worktrees/ambiguous-model-b-claude.GOkY2q/modules/model-b-avdm/src/session/base.rs:58-84`</small>

- `consume_grace_period` が型レベルで無料5分を控除し、ChargeableEnergy が負値や超過量を拒否

<!--
【時間: 45秒 | 累計: 13:35】

生成されたコードを見ると、とても美しいですね。

各行が型安全な操作になっています。1行目、SessionTimeline::betweenで時間範囲を検証します。2行目、consume_grace_periodで無料5分を自動的に控除します。3行目、ChargeableEnergy::allocateでエネルギーを検証します。そして最後に、SessionBill::settleで料金を計算します。

すべての操作がResult型を返すため、不正な値は型システムで排除されます。AIがこのパターンを学習して、再現してくれたわけです。

では次に、ChargeableEnergyがどのようなバグを防ぐのか、詳しく見ていきましょう。
-->

---

# ChargeableEnergy が防ぐバグ

**不変条件**: `billed <= total`（課金対象 ≦ 総エネルギー）を型で強制

```rust
pub fn new(total: KwhMilli, billed: KwhMilli) -> Result<Self, SessionValueError> {
  if billed > total {
    return Err(SessionValueError::EnergyOutOfRange {
      provided: u64::from(billed), max: u64::from(total)
    });
  }
  Ok(Self { total, billed })
}
```

**防ぐバグの例:**
- ❌ 按分ミス → 全量課金（model-a で発生: `billed_kwh_milli = session.kwh_milli`）
- ❌ 負のエネルギー値（scenario9）
- ❌ 上限超過（scenario15）

<!--
【時間: 45秒 | 累計: 14:20】

ChargeableEnergyの実装を詳しく見ていきます。

不変条件は1つだけです。課金対象エネルギーが総エネルギーを超えてはいけない。たったこれだけです。

しかし、この1つの不変条件が、3種類のバグを防いでいます。

1つ目、按分ミス。これはmodel-aで実際に発生したバグです。全量課金してしまうというものでした。

2つ目、負のエネルギー値。これはscenario9で検証しています。

3つ目、上限超過。これはscenario15で検証しています。

コンストラクタで検証するだけで、一度作られたChargeableEnergyは必ず正しい。これがAVDMの力です。では最後に、今回の学びをまとめます。
-->

---

## 学び

- **プロンプト解像度が最重要**: 曖昧指示では非AVDMがバグを再び生む
- **AVDM の防御力**: 値オブジェクトと不変条件で曖昧さを吸収
- **自動化の威力**: `run-worktree-all.sh` により、並列実験とログ収集が確実
- **記録の重要性**: 成果ログ＋動画で検証結果を「再演可能」に保管

<!--
【時間: 45秒 | 累計: 15:05】

今回の実験から得られた4つの学びをまとめます。

1つ目、プロンプトの解像度が最重要です。明確なプロンプトなら両方とも成功しますが、曖昧になると差が出ます。

2つ目、AVDMの防御力です。型システムが最後の砦となり、曖昧なプロンプトでもAVDMなら成功します。

3つ目、自動化の威力です。並列実行で効率的に比較実験ができました。

4つ目、記録の重要性です。すべてを記録することで、後から検証可能になります。

AI時代だからこそ、ドメインモデリングが重要です。これが今回の最大の発見です。

時間の都合で付録は省略しますが、実験の再現可能性については、git worktreeで完全隔離し、すべてのログを保存しています。

それでは、以上で発表を終わります。ご清聴ありがとうございました。ご質問があればお受けします。
-->

---

# 付録: デモ運用と自動化の工夫

**並列実験の自動化**
- `scripts/run-worktree-all.sh` で4パターンを同時実行
- 各実験は独立したworktreeで隔離（競合なし）
- ログ・PID・成果物を自動収集

**再現性の確保**
- タイムスタンプ付きディレクトリで実験を保存
- worktreeごと保存することで、生成コードを後から確認可能
- 動画録画で視覚的な証拠を残す

**運用上の工夫**
- 重要な実験結果は `experiments/` へ昇格
- デモは事前録画でリスク回避（ライブ実行の失敗を防ぐ）

<!--
【時間: 30秒 | 累計: 15:35】
※時間があれば話す。なければスキップ

時間があれば補足します。

実験の再現可能性を重視しました。git worktreeで完全隔離し、すべてのログを保存し、動画も証拠として残しています。

これにより、今日のプレゼンも実現できました。ありがとうございました。
-->

---
layout: center
---

## ご清聴ありがとうございました

**実験コード・ログ・スライド資料**

https://github.com/j5ik2o/ai-modeling-verification

<!--
【時間: 25秒 | 累計: 16:00】

改めまして、ご清聴ありがとうございました。

まとめますと、AVDMはAI時代のコード品質を支える重要な手法です。プロンプトの明確さも重要ですが、AVDMは保険になります。そして、実験基盤を整えることで、このような科学的な検証が可能になります。

今回の実験コード、すべてのログ、そしてこのスライド資料は、GitHubで公開しています。URLはスライドに記載の通りです。ぜひご覧ください。

何かご質問があれば、お願いします。
-->
